# Agent Design (Confirmed)

> 出典: `docs/implementation_plan.md` Phase 1.5「統制エージェント機構」から切り出し

---

## 1. 設計思想

SPECTRAは**自律行動が基本**であり、開発者は例外的に介入する。

| 区分 | 役割 |
|------|------|
| **SPECTRA（自律）** | 状況を認識し、判断し、行動する主体 |
| **開発者（例外）** | 最優先で上書きできる特権経路（バックドア） |

### 設計原則

| 原則 | 説明 |
|------|------|
| **目的駆動** | 開発者が設定した目的に応じて、自律的にタスクを生成・実行する |
| **安全停止** | 失敗時は停止し、再実行は明示承認を要求する |
| **承認必須** | 会話応答以外のアクションは全て承認制 |

---

## 2. 抽象フロー

```
┌─────────────────────────────────────────────────────────┐
│  [開発者] — いつでも最優先で上書き可能（全体に対する特権）  │
└─────────────────────────────────────────────────────────┘
                          ↓
[状況] → [自律判断] → [実行フロー] → [結果] → [状態]
              ↑                          ↓
            [記憶] ←─────────────────────┘
```

### 各要素の意味

| 要素 | 説明 |
|------|------|
| **開発者** | いつでもフロー全体に介入できる上位レイヤー（介入時は最優先） |
| **状況（Situation）** | 外部状況 + 内部状況 + 目的/目標/タスク（判断の入力すべて） |
| **自律判断** | 何をするかを決める（LLMが担当） |
| **実行フロー** | 承認 → 実行 → 観測（あらゆるアクションがこの流れを通る） |
| **結果** | 実行の出力 |
| **状態（State）** | 状況・意図・実行中・結果を保持する共通領域 |
| **記憶** | state.json（正本）+ events.jsonl（履歴正本）+ Grokのchatオブジェクト（補助） |

### 実行フローの汎用性

「承認 → 実行 → 観測」はあらゆるアクションを包摂する:

| アクション | 承認 | 実行 | 観測 |
|------------|------|------|------|
| 会話応答 | 自動承認 | 出力 | — |
| それ以外（操作・投稿・取得等） | 明示的に必要 | 実行 | 結果確認 |

---

## 3. 責務分担

### 機械制御 vs LLM制御の境界

```
[機械] 観察 → [LLM] 判断 → [機械] 承認 → [機械] 実行 → [機械] 記録
```

| 担当 | 責務 | 理由 |
|------|------|------|
| **機械制御** | 観察・承認・実行・記録・状態保存 | 確実性が必要（LLMに任せると不安定） |
| **LLM** | 判断（何をするか決める） | 柔軟性が必要（機械だと硬直） |

### 記録の粒度

- SPECTRAは自律的に行動し、結果を独り言のように記録する
- 実行内容と結果を簡潔に記録

---

## 4. 確定事項

### 構成

- [x] 自律判断・実行フロー・状態/記憶を分離した最小構成で進める
- [x] 単一LLMコアで十分（複数エージェント化は必須ではない）
- [x] 観察→判断→承認→実行→記録は機械制御、判断のみLLM

### 入力の正規化

- [x] 入力は最小構造で統一する:
  - `source`（入力元）: console | discord | roblox | x | ...
  - `authority`（権限）: developer | public（sourceから自動導出）
  - `surface`（表示面）: chat | cli | task | inspector | vitals
  - `text`（入力本文）
- [x] entry/channel の分離はやめ、source一本化
- [x] authority の表現: developer / public
- [x] surface 命名ルール: 1ワード・小文字・役割が直感的・一貫性重視
- [x] surface一覧: chat, cli, task, inspector, vitals

### 出力の正規化

- [x] 出力は最小構造で統一する:
  - `surface`（出力先）: chat | cli | task | inspector | vitals
  - `data`（出力内容）
- [x] type は不要（surfaceで意味が一意に決まる）
- [x] UIは「dataをそのまま表示」するだけ

**surfaceごとのdata:**

| surface | data の内容 |
|---------|-------------|
| chat | 文字列（表示する文） |
| cli | 文字列（表示する文） |
| task | state.json の最小構造（goals/tasks） |
| inspector | 推論の要約スナップショット（状況/意図/実行中/結果） |
| vitals | 実行環境のスナップショット（cpu/memory/network） |

### 判断サイクル

- [x] 判断サイクルは「状況（外部状況 + 内部状況 + 目的/目標）の変化」で回す
- [x] 目的/目標は常に状況の一部として判断対象に含める

### 自律と承認

- [x] 開発者の入力は例外扱いで、常に最優先で上書きされる
- [x] 自律範囲はend-to-end（判断→実行）を目指すが、現段階では承認必須で開始
- [x] 承認の例外（自動承認対象）はアクション種別のホワイトリストで定義
- [x] 承認は実行直前のみ（判断時ではなく、実行直前に1回）

### 状態管理

- [x] 状況 ≠ 状態（用語の分離確定）
  - 状況（Situation）: 判断の入力（一時的なスナップショット）
  - 状態（State）: 状況・意図・実行中・結果を保持する箱
- [x] 計画 = 目的/目標/タスク（用語の明確化）
  - 意図は「次の1手」、計画は「その1手が属する全体構成」

**状態テーブル（4項目）:**

| 項目 | 内容 | 保存場所 | 更新タイミング |
|------|------|----------|----------------|
| 状況 | 外部 + 内部 + 目的/目標/タスク | state.json（current.situation_summary） | 判断前 |
| 意図 | 状況を見て決めた、次の1手 | state.json（current.intent） | 判断直後 |
| 実行中 | 意図に基づくアクション | state.json（current.action） | 実行開始/終了 |
| 結果 | 成功/失敗 + 要約 | state.json（current.last_result）+ events.jsonl | 実行完了時 |

### Grok記憶との役割分担

| 層 | 期間 | 仕組み | 役割 | 正本？ |
|---|---|---|---|---|
| 短期 | セッション内 | chatオブジェクト | 直近の会話文脈 | ❌（補助） |
| 中期 | セッション跨ぎ | response ID | 連続会話の橋渡し | ❌（補助） |
| 長期 | 永続 | xAI Collections | 変わらない事実の保管 | ❌（必要時のみ） |
| **正本** | 永続 | state.json + events.jsonl | 計画 + 文脈 + 履歴 | ✅ |

- [x] Grok記憶は補助的（正本ではない）
- [x] 正本はファイル（state.json + events.jsonl）に統一

### 失敗時

- [x] 失敗時は即座に停止し、記録する

### 割り込みと優先度

- [x] 人間の指示は常に最優先
- [x] 割り込み時は即座に停止して切り替え
- [x] 中断されたタスクは要約し、再開/破棄を確認する

### 自己修正

- [x] 自己修正は小修正のみ許可（実行には承認が必要）
- [x] 小修正の定義: 目的に直接寄与し、かつ可逆であること
- [x] 可逆の定義: 以前の状態に戻せること
- [x] 自己修正の範囲: 設定/状態の調整のみ

### 承認フロー（詳細）

- [x] 承認要求の内容: 実行概要 + 影響範囲
- [x] 承認入力: y/n
- [x] 承認範囲: 全アクションに承認が必要
- [x] 却下時: 停止して終了
- [x] 承認メッセージ形式: 2行
- [x] 承認待ち中: アイドルのみ
- [x] 承認タイムアウト: なし

### 記録

- [x] 記録の出力先: チャット（独り言として表示）

### ログ・永続化（正本構成）

- [x] 正本は2ファイルのみ:
  - `state.json`: 現在の文脈 + 計画（目的/目標/タスク）
  - `events.jsonl`: 全入出力・実行の時系列ログ（追記型）
- [x] ログは常に記録する
- [x] ログの読者: 開発者 + SPECTRA（SPECTRAは失敗/エラー時のみ読む）
- [x] ログ保持: サイズベース（10MB上限、古いものから削除、直近200-500行のみ読む）

**state.json構造:**

```json
{
  "goals": [
    {"id": "G1", "name": "...", "tasks": [...], "status": "active"}
  ],
  "current": {
    "situation_summary": "状況の1文要約",
    "intent": "次の1手",
    "action": null,
    "last_result": {"status": "done", "summary": "..."}
  }
}
```

**events.jsonl形式:**

```json
{"time":"...","type":"input","source":"console","surface":"chat","text":"..."}
{"time":"...","type":"input","source":"console","surface":"cli","text":"ls"}
{"time":"...","type":"intent","action":"G1-T2を実行"}
{"time":"...","type":"exec","command":"ls","status":"done","output":"..."}
{"time":"...","type":"output","surface":"chat","data":"完了しました"}
{"time":"...","type":"output","surface":"cli","data":"file1.txt\nfile2.txt"}
{"time":"...","type":"goal_done","goal":{...}}
```

### 特権チャンネル

- [x] 特権チャンネル: Command UI + Discord（開発者サーバー）
- [x] 特権判定: 経路で判定（Command UI/Discordからの入力は自動的に特権扱い）
- [x] 特権の範囲: 目的、進行中タスク、ルールを上書き可能

### ルール変更

- [x] ルール変更は承認が必要、承認後は永続化
- [x] ルール変更は即座に適用、即時適用が不可能なら停止して報告 + 再起動手順を表示
- [x] 再起動提案: 手順を表示 + 即時実行を提案（実行には承認が必要）

### 状況と差分

- [x] 重要な差分の定義: 目的/目標に影響する変化のみ
- [x] 状況要約の長さ: 1文

### 目的→目標→タスク階層

- [x] 目標モデル: 目的→目標→タスク（3層階層）
- [x] 目標の更新: 達成まで固定
- [x] 目標の粒度: 1目標あたり5-10タスク
- [x] 目標完了条件: 全タスクがdoneまたはfail
- [x] 目標ステータス: active / done

### タスク

- [x] タスク完了条件: 成功/失敗のみ
- [x] タスク生成タイミング: 目標設定時に一括生成
- [x] タスク実行: 逐次のみ
- [x] タスク中断: 人の指示が入ったときのみ
- [x] 実行前チェック: なし
- [x] タスク情報フィールド: 名前のみ
- [x] タスク/目標テキスト形式: 短い自然言語
- [x] タスクステータス: pending / active / done / fail
- [x] タスクactive状態: 実行開始時にセット、done/failで解除
- [x] タスク失敗時: 失敗としてマークし、次のタスクへ進む（差し替えなし）

### ID形式

- [x] 目標ID形式: G1, G2, ...
- [x] タスクID形式: G1-T1, G1-T2, ...

### 完了率

- [x] 完了率: 表示時に計算（永続化しない）
- [x] 完了率計算: done / total

### メッセージ形式（統一）

```
タスク成功: [G1-T1] DONE タスク名
タスク失敗: [G1-T1] FAIL タスク名 / 原因
目標完了:   [G1] DONE 目標名 / 80%
```

- [x] ステータス語彙: PENDING / ACTIVE / DONE / FAIL
- [x] 明示的なGOAL/TASKラベル: なし
- [x] 失敗原因形式: 1短文（技術的）
- [x] タスク成功記録: ペイン + 1行チャット
- [x] タスク失敗記録: ペイン + 1行チャット（原因付き）
- [x] 目標完了記録: チャット + ペイン（完了 + 率）

### 計画ペイン

- [x] タスク表示: 専用ペイン
- [x] ペイン表示対象: active目標のみ（done目標は非表示、ファイルには残る）
- [x] active目標は全タスクを表示（pending/active/done/fail）
- [x] 複数のactive目標を許可
- [x] ペイン更新タイミング: タスク/目標ステータス変化時
- [x] ペイン内容: タスク名 + ステータス + 目標ID
- [x] ペイン初期状態: 全て折りたたみ
- [x] ペイン自動展開: なし（手動のみ）
- [x] ペイン目標順序: 古い順
- [x] ペインタスク順序: 作成順
- [x] 追加フィルタUI: なし（表示範囲固定）

### 計画状態の永続化

**state.json（正本）:**
- [x] 保存先: logs/state.json（プロジェクトルート固定）
- [x] 形式: JSON（2スペースインデント、UTF-8、BOMなし）
- [x] 保存方式: 状態変化ごとに全上書き（即座）
- [x] 構造: goals[] + current{}
- [x] goals: active目標のみ（doneはevents.jsonlに記録）
- [x] current: situation_summary, intent, action, last_result
- [x] 目標フィールド: id, name, tasks, status
- [x] タスクフィールド: id, name, status
- [x] 更新対象: タスクステータス + 目標ステータス + current
- [x] 更新順序: state.json書き込み → ペイン更新
- [x] 書き込み競合: 最後の書き込みが勝つ

**events.jsonl（履歴正本）:**
- [x] 保存先: logs/events.jsonl
- [x] 形式: JSON Lines（1行1イベント、UTF-8、BOMなし）
- [x] 保存方式: 追記型（過去を消さない）
- [x] 記録対象: 入力 / 意図 / 実行 / 出力 / 目標完了
- [x] 完了目標: events.jsonlにgoal_doneイベントとして記録

### 永続化のエラー処理

- [x] 読み込みタイミング: 起動時 + 状態更新時
- [x] ファイル欠損時: 空の `{"goals": [], "current": {}}` を作成して続行
- [x] 読み込み失敗: 停止して報告
- [x] 書き込み失敗: 停止して報告（fail-fast、ペイン更新なし）
- [x] ファイル破損時: 停止して報告

---

### データフロー

- [x] 単一chatオブジェクトを基本（疑似マルチエージェントは不要）
- [x] 並列チャンネル操作時も単一chatで十分（source/surfaceで文脈分離）
- [x] 必要になったらチャンネル別に分離（拡張ポイントとして残す）

```
[Input]
source/authority/surface/text
        |
        v
[Core]
状況を更新 → 意図を決定 → 実行中を更新 → 結果を更新
        |
        +--> [Output]
        |     surface = chat/cli/task/inspector/vitals
        |
        +--> [Persistence]
              state.json + events.jsonl
```

---

## 5. 未確定（検討中）

- [ ] inspector / vitals の具体フィールド

